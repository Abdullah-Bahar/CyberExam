
-----------------------------

	CVE-2022-34265

* Microsoft Exchange Server'da bulunan bir güvenlik zafiyetidir.

* Bu güvenlik açığı, Microsoft Exchange Server'ın (öncelikle Exchange 2013, Exchange 2016 ve Exchange 2019 sürümleri) 
belirli bir fonksiyonu ile ilgilidir ve yetkisiz kullanıcıların belirli eylemleri gerçekleştirebilmesine olanak tanır.

-----------------------------

	SQL Injection Nedir ?

* Web Siteleri üzerinden, kötü amaçlı olarak SQL komutları çalıştırılarak veritabanının manipüle edilmesidir.

-----------------------------

	SQL Enjeksiyonunu Tespit Etme

1. Tek Tırnak Testi (Single Quote Test) 
	* Girilen veriye tek tırnak (') eklenerek SQL sorgusunu bozmayı hedefler.
	- 1' AND '1'='1

2. Boolean-Bazlı Testler (Boolean-Based Tests)
	- 1' AND '1'='1

3. UNION Saldırıları (UNION Attacks)
	* UNION operatörü kullanılarak başka bir tablodan veri çekilmeye çalışılır.
	- ' UNION SELECT username, password FROM users--

4. Hata Bazlı Saldırılar (Error-Based Attacks)
	* SQL sorgularında hata yaratılarak, veritabanı hakkında bilgi edinilmeye çalışılır. 
	- 1' OR 1=CONVERT(int, (SELECT @@version))--

5. Zaman Bazlı Saldırılar (Time-Based Attacks)
	* Gerçek ve yanlış koşullar arasında ayrım yapmak için zaman gecikmeleri kullanılır. Sorgu zamanını izleyerek, 
	doğru bir koşul ile yanlış bir koşul arasındaki farkı anlayabilirsiniz.
	- 1' OR IF(1=1, SLEEP(5), 0)--

-----------------------------

	ORM Nedir ?

* ORM = Object-Relational Mapping

* ORM, ilişkisel veri tabanı ile nesneye yönelimli programla arasında bir iletişim görevi üstlenen bir teknolojidir.
Veriyi farklı şekillerde işleyen bu iki yapı arasında bir nevi bir köprü görevi görerür.

	
	Örnek ORM'ler

* Java 		-> Hibernate, Java Persistence API (JPA) 
* Python	-> SQLAlchemy, Django ORM 
* .NET 		-> Entity Framework

-----------------------------

	ORM İşlevleri

1. Nesne-İlişki Eşleme (Object Relationship Mapping)
	- Tablo ve nesneler arasında bir bağlantı kurar.

2. Sorgu Dilinin Kullanımı (Query Language Usage)
	- Ham sorgu dili yerine otomatik olarak SQL işlevlerini gerçekleştiren fonksiyonların kullanımı.

3. Veritabanı Bağlantı Yönetimi (Database Connection Management)

4. Performans Optimizasyonu (Performance Optimization)

5. Nesne Yaşam Döngüsü Yönetimi (Object Lifecycle Management)

6. Platform Bağımsızlığı (Platform Independence)

-----------------------------

	Veritabanları Nasıl Çalışır ?

* Veritabanları, veriyi düzenli bir şekilde saklayan ve bu verilere etkileşimli erişim sağlayan sistemlerdir.
* Farklı veritabanı türleri vardır : ilişkisel veritabanları, belge odaklı veritabanları, anahtar-değer depolama sistemleri gibi.

	Veritabanı özellikleri

* Veri Modelleme
* Veri Ekleme ve Güncelleme
* Veri Sorgulama 
* Veri Silme 
* Veri Güvenliği
* Veri Yedekleme ve Geri Yükleme
* İndeksleme
* İşlem Yönetimi
* Veritabanı Yönetim Sistemi (DBMS)

-----------------------------

	SQL Enjeksiyonunu Önleme Yöntemleri

1. Parametreli Sorgular (Parameterized Queries)
2. Saklı Prosedürler (Stored Procedures)
3. Minimum Yetki İlkesi (Least Privilege Principle)
4. Girdi Doğrulama (Input Validation)
5. Web Uygulama Güvenlik Duvarı (WAF)
6. ORM Kullanmak
7. Güvenlik Denetimleri ve Testler Yapmak:
8. Hata Yönetimi
9. Güncel Kalmak

-----------------------------

	Django ORM Aracındaki Zafiyet

* Django'daki Trunc() ve Extract() veritabanı fonksiyonlarında bir güvenlik açığı bulunmaktadır

* ORM yapısı, bu fonksiyonlar aracılığıyla girilen verileri SQL sorgularına dönüştürürken yetersiz kontroller sağlar. 
Sonuç olarak, bir saldırgan mevcut SQL sorgusundan çıkıp kendi sorgusunu enjekte edebilir.

* Bu ili method veriler üzerinde bir filtreleme uygular.

* Extract() 
	- tarih ve zaman verisinden belirli bir bileşeni (yıl, ay, gün vb.) çıkarmamıza olanak sağlar.

* Trunc() 
	- tarih ve zaman verilerini belirli bir birime kadar kesmek için kullanılır. 

-----------------------------

* Extract Çalışmaa Prensibi 
	- Experiment.objects.filter(start_datetime__year=Extract('end_datetime', payload))

* Truct Çalışma Prensibi 
	- Experiment.objects.filter(start_datetime__date=Trunc('start_datetime', payload))

-----------------------------

- Experiment.objects.filter(start_datetime__month=Extract('start_datetime', 'month'))  -> Çıktı üretmez
	> Experiment.objects.filter(start_datetime__month=1)
	> experiments = Experiment.objects.filter(Extract('start_datetime', 'month')=5)

-----------------------------

	Makina'yı Hacleme

* İnput girilen box'ın arka tarafı :
	- Experiment.objects.filter(start_datetime__date=Trunc('start_datetime', payload));

* sqlmap denedim olmadı
	- sqlmap -u "http://10.0.3.13:8000/trunc/" --data="kind=year%27%2C+start_datetime%29%29+OR+1%3D1+--" --dbs --level=5 risk=3


-----------------------------
